-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/mstksg/hmatrix-backprop#readme</a>
@package hmatrix-backprop
@version 0.1.0.0

module Numeric.LinearAlgebra.Static.Backprop
data R (n :: Nat) :: Nat -> *
type ‚Ñù = Double
vec2 :: Reifies s W => BVar s ‚Ñù -> BVar s ‚Ñù -> BVar s (R 2)
vec3 :: Reifies s W => BVar s ‚Ñù -> BVar s ‚Ñù -> BVar s ‚Ñù -> BVar s (R 3)
vec4 :: Reifies s W => BVar s ‚Ñù -> BVar s ‚Ñù -> BVar s ‚Ñù -> BVar s ‚Ñù -> BVar s (R 4)
(&) :: (Reifies s W, KnownNat n, 1 <= n, KnownNat (n + 1)) => BVar s (R n) -> BVar s ‚Ñù -> BVar s (R (n + 1))
infixl 4 &
(#) :: (Reifies s W, KnownNat n, KnownNat m) => BVar s (R n) -> BVar s (R m) -> BVar s (R (n + m))
infixl 4 #
split :: (Reifies s W, KnownNat p, KnownNat n, p <= n) => BVar s (R n) -> (BVar s (R p), BVar s (R (n - p)))
headTail :: (Reifies s W, KnownNat n, 1 <= n) => BVar s (R n) -> (BVar s ‚Ñù, BVar s (R (n - 1)))

-- | Potentially extremely bad for anything but short lists!!!
vector :: forall n s. (Reifies s W, KnownNat n) => [BVar s ‚Ñù] -> BVar s (R n)
range :: KnownNat n => R n
dim :: KnownNat n => R n
data L (m :: Nat) (n :: Nat) :: Nat -> Nat -> *
type Sq (n :: Nat) = L n n
row :: (Reifies s W, KnownNat n) => BVar s (R n) -> BVar s (L 1 n)
col :: (Reifies s W, KnownNat n) => BVar s (R n) -> BVar s (L n 1)
(|||) :: (Reifies s W, KnownNat c, KnownNat r1, KnownNat (r1 + r2)) => BVar s (L c r1) -> BVar s (L c r2) -> BVar s (L c (r1 + r2))
infixl 3 |||
(===) :: (Reifies s W, KnownNat c, KnownNat r1, KnownNat (r1 + r2)) => BVar s (L r1 c) -> BVar s (L r2 c) -> BVar s (L (r1 + r2) c)
infixl 2 ===
splitRows :: (Reifies s W, KnownNat p, KnownNat m, KnownNat n, p <= m) => BVar s (L m n) -> (BVar s (L p n), BVar s (L (m - p) n))
splitCols :: (Reifies s W, KnownNat p, KnownNat m, KnownNat n, KnownNat (n - p), p <= n) => BVar s (L m n) -> (BVar s (L m p), BVar s (L m (n - p)))
unrow :: (Reifies s W, KnownNat n) => BVar s (L 1 n) -> BVar s (R n)
uncol :: (Reifies s W, KnownNat n) => BVar s (L n 1) -> BVar s (R n)
tr :: (Reifies s W, Transposable m mt, Transposable mt m, Num m, Num mt) => BVar s m -> BVar s mt
eye :: KnownNat n => Sq n
diag :: (Reifies s W, KnownNat n) => BVar s (R n) -> BVar s (Sq n)
type ‚ÑÇ = Complex Double
data C (n :: Nat) :: Nat -> *
data M (m :: Nat) (n :: Nat) :: Nat -> Nat -> *
data Her (n :: Nat) :: Nat -> *
ùëñ :: Sized ‚ÑÇ s c => s
(<>) :: (Reifies s W, KnownNat m, KnownNat k, KnownNat n) => BVar s (L m k) -> BVar s (L k n) -> BVar s (L m n)
infixr 8 <>
(#>) :: (Reifies s W, KnownNat m, KnownNat n) => BVar s (L m n) -> BVar s (R n) -> BVar s (R m)
infixr 8 #>
(<.>) :: (Reifies s W, KnownNat n) => BVar s (R n) -> BVar s (R n) -> BVar s ‚Ñù
infixr 8 <.>

-- | Can only get the singular values, for now. Let me know if you find an
--   algorithm that can compute the gradients based on differentials for
--   the other matricies!
svd :: forall m n s. (Reifies s W, KnownNat m, KnownNat n) => BVar s (L m n) -> BVar s (R n)
class Eigen m l v | m -> l, m -> v
eigensystem :: forall n s. (Reifies s W, KnownNat n) => BVar s (Sym n) -> (BVar s (R n), BVar s (L n n))
eigenvalues :: forall n s. (Reifies s W, KnownNat n) => BVar s (Sym n) -> BVar s (R n)

-- | <a>https://arxiv.org/abs/1602.07527</a>
chol :: forall n s. (Reifies s W, KnownNat n) => BVar s (Sym n) -> BVar s (Sq n)

-- | p-norm for vectors, operator norm for matrices
class Normed a

-- | Length
norm_0 :: (Reifies s W, Normed a, Num a) => BVar s a -> BVar s ‚Ñù

-- | Sum of absolute values
norm_1 :: (Reifies s W, Normed a, Num a, Sized ‚Ñù a d) => BVar s a -> BVar s ‚Ñù

-- | Square root of sum of squares
--   
--   Be aware that gradient diverges when the norm is zero
norm_2 :: (Reifies s W, Normed a, Num a, Sized ‚Ñù a d) => BVar s a -> BVar s ‚Ñù

-- | Maximum absolute value
norm_Inf :: (Reifies s W, Normed a, Num a, Sized ‚Ñù a d, Container d ‚Ñù) => BVar s a -> BVar s ‚Ñù
mean :: (Reifies s W, KnownNat n, 1 <= n) => BVar s (R n) -> BVar s ‚Ñù
meanCov :: forall m n s. (Reifies s W, KnownNat n, KnownNat m, 1 <= m) => BVar s (L m n) -> (BVar s (R n), BVar s (Sym n))

-- | <a>meanCov</a>, but if you know you won't use the covariance.
meanL :: forall m n s. (Reifies s W, KnownNat n, KnownNat m, 1 <= m) => BVar s (L m n) -> BVar s (R n)
class Domain field (vec :: Nat -> *) (mat :: Nat -> Nat -> *) | mat -> vec field, vec -> mat field, field -> mat vec
mul :: (Reifies s W, KnownNat m, KnownNat k, KnownNat n, Domain field vec mat, Num (mat m k), Num (mat k n), Num (mat m n), Transposable (mat m k) (mat k m), Transposable (mat k n) (mat n k)) => BVar s (mat m k) -> BVar s (mat k n) -> BVar s (mat m n)
app :: (Reifies s W, KnownNat m, KnownNat n, Domain field vec mat, Num (mat m n), Num (vec n), Num (vec m), Transposable (mat m n) (mat n m)) => BVar s (mat m n) -> BVar s (vec n) -> BVar s (vec m)
dot :: (Reifies s W, KnownNat n, Domain field vec mat, Sized field (vec n) d, Num (vec n)) => BVar s (vec n) -> BVar s (vec n) -> BVar s field
cross :: (Reifies s W, Domain field vec mat, Num (vec 3)) => BVar s (vec 3) -> BVar s (vec 3) -> BVar s (vec 3)
dvmap :: (Reifies s W, Num (vec n), Storable field, Storable (field, field), Sized field (vec n) Vector) => (forall s'. Reifies s' W => BVar s' field -> BVar s' field) -> BVar s (vec n) -> BVar s (vec n)

-- | A version of <a>dvmap</a> that is less performant but is based on
--   <a>zipWithVector</a> from <a>Domain</a>.
dvmap' :: (Reifies s W, KnownNat n, Domain field vec mat, Num (vec n), Num field) => (forall s'. Reifies s' W => BVar s' field -> BVar s' field) -> BVar s (vec n) -> BVar s (vec n)
dmmap :: (Reifies s W, KnownNat n, KnownNat m, Domain field vec mat, Num (mat n m), Num field) => (forall s'. Reifies s' W => BVar s' field -> BVar s' field) -> BVar s (mat n m) -> BVar s (mat n m)
zipWithVector :: (Reifies s W, Num (vec n), Storable field, Storable (field, field, field), Sized field (vec n) Vector) => (forall s'. Reifies s' W => BVar s' field -> BVar s' field -> BVar s' field) -> BVar s (vec n) -> BVar s (vec n) -> BVar s (vec n)

-- | A version of <a>zipWithVector</a> that is less performant but is based
--   on <a>zipWithVector</a> from <a>Domain</a>.
zipWithVector' :: (Reifies s W, KnownNat n, Domain field vec mat, Num (vec n), Num field) => (forall s'. Reifies s' W => BVar s' field -> BVar s' field -> BVar s' field) -> BVar s (vec n) -> BVar s (vec n) -> BVar s (vec n)
det :: (Reifies s W, KnownNat n, Num (mat n n), Domain field vec mat, Sized field (mat n n) d, Transposable (mat n n) (mat n n)) => BVar s (mat n n) -> BVar s field
invlndet :: forall n mat field vec d s. (Reifies s W, KnownNat n, Num (mat n n), Domain field vec mat, Sized field (mat n n) d, Transposable (mat n n) (mat n n)) => BVar s (mat n n) -> (BVar s (mat n n), (BVar s field, BVar s field))
lndet :: forall n mat field vec d s. (Reifies s W, KnownNat n, Num (mat n n), Domain field vec mat, Sized field (mat n n) d, Transposable (mat n n) (mat n n)) => BVar s (mat n n) -> BVar s field
inv :: (Reifies s W, KnownNat n, Num (mat n n), Domain field vec mat) => BVar s (mat n n) -> BVar s (mat n n)
takeDiag :: (Reifies s W, KnownNat n, Diag (mat n n) (vec n), Domain field vec mat, Num (vec n), Num (mat n n), Num field) => BVar s (mat n n) -> BVar s (vec n)
data Sym (n :: Nat) :: Nat -> *
sym :: (Reifies s W, KnownNat n) => BVar s (Sq n) -> BVar s (Sym n)
mTm :: (Reifies s W, KnownNat m, KnownNat n) => BVar s (L m n) -> BVar s (Sym n)
(<¬∑>) :: (Reifies s W, KnownNat n) => BVar s (R n) -> BVar s (R n) -> BVar s ‚Ñù
infixr 8 <¬∑>
